/*
 * datapage
 * Simple Pagination Data Object
 * https://github.com/trapple/datapagejs.git
 * Copyright 2013 trapple
 * Version: 2.0.0
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).DataPage={})}(this,function(t){"use strict";function e(t,e,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!i:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(t):i?i.value:e.get(t)}function s(t,e,s,i,r){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!r:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?r.call(t,s):r?r.value=s:e.set(t,s),s}var i,r,a,n;"function"==typeof SuppressedError&&SuppressedError;i=new WeakMap,r=new WeakMap,a=new WeakMap,n=new WeakMap,t.default=class{constructor(t,h,o,f){i.set(this,void 0),r.set(this,void 0),a.set(this,void 0),n.set(this,void 0),s(this,i,t||0,"f"),s(this,r,h||10,"f"),s(this,a,o||1,"f"),s(this,n,f||10,"f"),s(this,i,this.parseUnsignedInt(e(this,i,"f")),"f"),s(this,r,this.parseVal(e(this,r,"f")),"f"),s(this,a,this.parseVal(e(this,a,"f")),"f"),s(this,n,this.parseVal(e(this,n,"f")),"f")}entriesPerPage(t){return void 0!==t&&s(this,r,this.parseVal(t),"f"),e(this,r,"f")}currentPage(t){if(void 0!==t){const i=this.parseVal(t);return s(this,a,i,"f"),i>this.lastPage()&&s(this,a,this.lastPage(),"f"),e(this,a,"f")}return e(this,a,"f")}totalEntries(t){return void 0!==t&&s(this,i,this.parseUnsignedInt(t),"f"),e(this,i,"f")}entriesOnThisPage(){return 0===e(this,i,"f")?0:this.last()-this.first()+1}firstPage(){return 1}lastPage(){const t=e(this,i,"f")/e(this,r,"f");let s;return s=t==parseInt(t.toString())?t:1+parseInt(t.toString()),s<1&&(s=1),s}first(){return 0===e(this,i,"f")?0:(e(this,a,"f")-1)*e(this,r,"f")+1}last(){return e(this,a,"f")==this.lastPage()?e(this,i,"f"):e(this,a,"f")*e(this,r,"f")}previousPage(){return e(this,a,"f")>1?e(this,a,"f")-1:void 0}nextPage(){return e(this,a,"f")<this.lastPage()?e(this,a,"f")+1:void 0}pagesPerPageset(t){return void 0!==t&&(s(this,n,this.parseVal(t),"f"),e(this,n,"f")>this.lastPage()&&s(this,n,this.lastPage(),"f")),e(this,n,"f")}pageset(){let t,s=[],i=0;const r=e(this,n,"f");for(t=this.firstPage();t<=this.lastPage();t++)s.push(t);return e(this,a,"f")>parseInt((r/2).toString())&&(i=e(this,a,"f")-parseInt((r/2).toString())-1),e(this,a,"f")+parseInt((r/2).toString())>this.lastPage()&&(i=this.lastPage()-r),s.length>r&&(s=s.splice(i,r)),s}hasNextPageset(){return this.pageset()[e(this,n,"f")-1]!==this.lastPage()}hasPreviousPageset(){return this.firstPage()!==this.pageset()[0]}parseVal(t){const e=parseInt(t);if(isNaN(e))throw new Error(`Invalid number: ${t}`);if(e<1)throw new Error(`Number must be positive: ${e}`);return e}parseUnsignedInt(t){const e=parseInt(t);if(isNaN(e))throw new Error(`Invalid number: ${t}`);return e}},Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=datapage.min.js.map
